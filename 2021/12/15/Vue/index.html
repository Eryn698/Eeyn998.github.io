<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Vue |  Hexo</title>
  <meta name="generator" content="hexo-theme-ayer">
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Vue"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Vue
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/12/15/Vue/" class="article-date">
  <time datetime="2021-12-15T03:05:31.000Z" itemprop="datePublished">2021-12-15</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">11.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">42 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="一-VUE"><a href="#一-VUE" class="headerlink" title="一.    VUE"></a>一.    VUE</h1><h4 id="VUE的基本原理"><a href="#VUE的基本原理" class="headerlink" title="VUE的基本原理"></a>VUE的基本原理</h4><p>一个vue实例创建时,会遍历data中的属性,用Object.defineProperty(vue3.0中使用proxy)将它们转化为getter/setter,并在内部追踪相关依赖,在属性被访问和修改时通知变化</p>
<p>每个组件都有相应的watcher实例,它会在组件渲染过程中将属性记录为依赖,当依赖项的setter被调用时通知watcher重新计算,致使关联的组件更新</p>
<h4 id="VUE的优点"><a href="#VUE的优点" class="headerlink" title="VUE的优点"></a>VUE的优点</h4><p>轻量级框架</p>
<p>上手快,学习成本低</p>
<p>双向数据绑定,保留了angular的特点,数据操作更简单</p>
<p>组件化,保留了react的特点,实现了html的封装和重用,在构建单页面应用方面有着独特的优势</p>
<p>视图、数据、结构分离,使数据更改更简单</p>
<p>虚拟DOM,操作DOM是非常消耗性能的,不再使用原生的DOM操作节点,极大解放了DOM操作</p>
<p>相较于react运行速度更快</p>
<h4 id="双向数据绑定原理"><a href="#双向数据绑定原理" class="headerlink" title="双向数据绑定原理:"></a>双向数据绑定原理:</h4><p>采用数据劫持结合发布者-订阅者模式的方式,通过Object.defineProperty()来劫持各个属性的setter, getter,在数据变动时发布消息给订阅者,触发相应的回调</p>
<h4 id="单向数据流和双向数据流的理解"><a href="#单向数据流和双向数据流的理解" class="headerlink" title="单向数据流和双向数据流的理解"></a>单向数据流和双向数据流的理解</h4><ul>
<li><p>v-bind和vuex就是单向数据流</p>
<p>如一个父组件有两个子组件，分别为a和b ，父组件向子组件传递数据，两个组件都接收到了父组件传递过来的数据，在组件a中修改父组件传递过来的数据，子组件b和父组件的值不会发生变化 这就是单向的数据流</p>
</li>
<li><p>v-model就是双向数据流</p>
<p>Model数据变化会触发View的刷新， View层用户改变数据也会在Model中同步</p>
</li>
</ul>
<h4 id="defineProperty-的使用方法"><a href="#defineProperty-的使用方法" class="headerlink" title="defineProperty()的使用方法"></a>defineProperty()的使用方法</h4><p>defineProperty()有三个参数</p>
<ul>
<li><p>1.将要被修改的对象</p>
</li>
<li><p>2.将要被修改的对象的属性</p>
</li>
<li><p>3.将要被修改的属性的描述符,就是一个对象,里面有两个属性get和set</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    <span class="attr">_year</span>: <span class="number">2004</span>,</span><br><span class="line">    <span class="attr">edition</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>._year = newValue;</span><br><span class="line">            <span class="built_in">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition);  <span class="comment">//2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="v-model实现原理"><a href="#v-model实现原理" class="headerlink" title="v-model实现原理"></a>v-model实现原理</h4><p>v-model实际上是一个语法糖</p>
<p>v-bind绑定value指向message变量</p>
<p>v-on绑定input事件</p>
<p>触发input事件时通过$event.target.value将值赋给message</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;sth&quot;</span> /&gt;</span><br><span class="line"><span class="comment">//  等同于</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">v-bind:value</span>=<span class="string">&quot;message&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">v-on:input</span>=<span class="string">&quot;message=$event.target.value&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="使用Object-defineProperty-缺点"><a href="#使用Object-defineProperty-缺点" class="headerlink" title="使用Object.defineProperty()缺点:"></a>使用Object.defineProperty()缺点:</h4><p>无法检测到对象属性的新增或删除 无法监听数组变化, Vue 内部通过重写函数的方式解决了这个问题 </p>
<h4 id="Vue3-0如何解决Object-defineProperty-缺点"><a href="#Vue3-0如何解决Object-defineProperty-缺点" class="headerlink" title="Vue3.0如何解决Object.defineProperty()缺点:"></a>Vue3.0如何解决Object.defineProperty()缺点:</h4><p>Vue3.0中使用Proxy(对象代理)可以完美的监听到任何数据的变化<br>缺点:兼容性问题</p>
<h4 id="data为什么是一个函数而不是对象"><a href="#data为什么是一个函数而不是对象" class="headerlink" title="data为什么是一个函数而不是对象:"></a>data为什么是一个函数而不是对象:</h4><p>javascript的对象是引用类型，多个组件引用同一个data对象时，当其中一个组件修改对象的数据时其他组件的数据也会发生变化</p>
<p>写成函数的形式当组件复用时，就会返回一个新的data,每个组件都有私有数据空间，不会影响其他组件 </p>
<h4 id="常见的事件修饰符"><a href="#常见的事件修饰符" class="headerlink" title="常见的事件修饰符"></a>常见的事件修饰符</h4><p>.stop 防止冒泡</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click=<span class="string">&quot;div&quot;</span>&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;button&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>    </span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">// 当点击button时，先执行button的点击事件，再执行div的点击事件，加上.stop后，就只会执行button的</span></span><br></pre></td></tr></table></figure>



<p>.prevent 防止执行预设行为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;http://www.baidu.com&quot;</span> @click.prevent=<span class="string">&quot;a&quot;</span>&gt;百度&lt;/a&gt;</span><br><span class="line"><span class="comment">// 加上.prevent后，就会阻止默认的跳转行为</span></span><br></pre></td></tr></table></figure>



<p>.captrue 与事件冒泡的方向相反，事件捕获由外到内</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click.capture=<span class="string">&quot;div&quot;</span>&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;button&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>    </span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">// 先触发div事件，再触发button事件</span></span><br></pre></td></tr></table></figure>



<p>.self 只会触发自身事件,不包含子元素 </p>
<p>.once 只触发一次</p>
<h4 id="MVVM、MVC、MVP的区别"><a href="#MVVM、MVC、MVP的区别" class="headerlink" title="MVVM、MVC、MVP的区别:"></a>MVVM、MVC、MVP的区别:</h4><p>MVC,MVP,MVVM是三种常见的软件架构设计模式, 主要通过分离关注点的方式来组织代码结构 </p>
<ul>
<li><p>MVVM</p>
<p>MVVM分为View、Model、VIewModel</p>
<p>View代表UI视图,负责数据显示</p>
<p>Model代表数据模型,数据和业务逻辑都在Model中定义 </p>
<p>ViewModel负责监听Model中数据的改变并且控制视图的更新,处理用户交互操作</p>
<p>Model和View是没有直接联系的 它们是通过ViewModel进行联系的</p>
<p>Model和ViewModel有着双向数据绑定的关系 </p>
<p>Model数据变化会触发View的刷新 View层用户改变数据也会在Model中同步</p>
</li>
<li><p>MVC</p>
<p>MVC分为Model、View、Controller</p>
<p>View负责页面的显示逻辑</p>
<p>Model负责存储页面的业务数据,以及对数据的操作</p>
<p>Controller层是View和Model的纽带,主要负责用户与应用的响应操作</p>
<p>view发布指令给controller，controller选择model，model驱动view</p>
</li>
<li><p>MVP</p>
<p>MVP与MVC唯一的不同点在于Presenter和Controller</p>
<p>MVP通过使用Presenter来实现View层和Model层的解耦,View层的接口暴露给了Presenter,可以实现View和Model的同步更新</p>
<p>MVC中的Controller只知道Model的接口,没有办法控制View层更新</p>
</li>
</ul>
<h4 id="对于axios的理解"><a href="#对于axios的理解" class="headerlink" title="对于axios的理解:"></a>对于axios的理解:</h4><p>axios是一种基于Promise封装的HTTP客户端，是对ajax的进一步封装</p>
<p>特点：</p>
<p>浏览器端发起XMLHttpRequest请求</p>
<p>node端发起http请求</p>
<p>支持Promise API</p>
<p>可以拦截请求和响应</p>
<p>自动转换成JSON数据</p>
<p>能够取消请求<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41772754/article/details/88258051">https://blog.csdn.net/qq_41772754/article/details/88258051</a></p>
<p>客户端支持抵御XSRF攻击<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangjiachen666/p/11351295.html">https://www.cnblogs.com/wangjiachen666/p/11351295.html</a></p>
<h4 id="axios-ajax请求一般放在哪个钩子函数中"><a href="#axios-ajax请求一般放在哪个钩子函数中" class="headerlink" title="axios || ajax请求一般放在哪个钩子函数中"></a>axios || ajax请求一般放在哪个钩子函数中</h4><p>一般放在created钩子函数中,因为此时data已经初始化,可以缓存获取到的数据，并且请求比较快，用户体验好</p>
<p>mounted中也可以发送请求,但是由于mounted是在模板渲染成html页面后调用,请求比较慢，如果数据比较庞大，这时候可能会导致页面闪屏</p>
<h4 id="ajax、fetch的区别"><a href="#ajax、fetch的区别" class="headerlink" title="ajax、fetch的区别"></a>ajax、fetch的区别</h4><ul>
<li><p>ajax</p>
<p>ajax是一种创建交互式网页应用的网页开发技术</p>
<p>是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术</p>
<p>本质是使用XMLHttpRequest对象来请求数据</p>
<p>它是jquery库里自带的一个方法</p>
</li>
<li><p>fetch</p>
<p>fetch是原生js，没有使用XMLHttpRequest对象</p>
<p>基于标准Peomise实现，支持async/await</p>
</li>
</ul>
<h4 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别:"></a>v-if和v-show的区别:</h4><p>v-if是动态的向DOM树内添加或删除元素 </p>
<p>v-show是通过设置DOM元素的display来控制元素的显示隐藏</p>
<p>v-if有更高的切换消耗 </p>
<p>v-show有更高的初始渲染消耗</p>
<p>v-if适合运营条件不大改变 </p>
<p>v-show适合频繁的切换</p>
<p>一般权限按钮上会用到v-if</p>
<h4 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h4><ul>
<li><p>v-if</p>
<p>通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</p>
</li>
<li><p>v-for</p>
<p> 通过为每个列表项提供一个 key 值 ，以便Vue跟踪元素的身份，从而高效的更新渲染虚拟DOM</p>
</li>
</ul>
<h4 id="为什么不建议用index作为key的值"><a href="#为什么不建议用index作为key的值" class="headerlink" title="为什么不建议用index作为key的值"></a>为什么不建议用index作为key的值</h4><p>如果使用index,不管数组怎么变化下标都是0,1,2，导致vue会复用错误的旧子节点</p>
<h4 id="插槽的作用"><a href="#插槽的作用" class="headerlink" title="插槽的作用"></a>插槽的作用</h4><p>一般在组件封装的时候使用</p>
<p>对已封装好的组件插入自己想要定义的不同组件</p>
<h4 id="组件通信的方式"><a href="#组件通信的方式" class="headerlink" title="组件通信的方式"></a>组件通信的方式</h4><p>父组件通过props向子组件传值</p>
<p>子组件通过$emit发布订阅父组件监听</p>
<p>ref和$refs可以获取整个子组件的数据和方法</p>
<p>vuex全局状态管理工具</p>
<p>provide、inject</p>
<p>$parent、$children</p>
<p>使用 eventBus 事件总线来处理非父子组件的传值</p>
<ul>
<li><p>创建eventBus事件总线 使用bus.$emit触发自定义事件传递参数</p>
</li>
<li><p>通过bus.$on监听自定义事件处理传递来的参数</p>
</li>
</ul>
<h4 id="路由的传参方式"><a href="#路由的传参方式" class="headerlink" title="路由的传参方式:"></a>路由的传参方式:</h4><p>直接通过$router.push路径中携带参数 路由配置路径中需要预留参数位置  可以通过设置路由中的 “props:true” 让子组件通过props获取参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;examine&quot;</span> @click=<span class="string">&quot;insurance(2)&quot;</span>&gt;查看详情&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">methods：&#123;</span><br><span class="line">  <span class="function"><span class="title">insurance</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">       <span class="comment">//直接调用$router.push 实现携带参数的跳转</span></span><br><span class="line">        <span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">`/particulars/<span class="subst">$&#123;id&#125;</span>`</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 路由配置</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&#x27;/particulars/:id&#x27;</span>,</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;particulars&#x27;</span>,</span><br><span class="line">     <span class="attr">component</span>: particulars</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>query传参 通过path来引入 query对象携带参数 传递的参数会显示在url后面 通过this.$route.query获取参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">methods：&#123;</span><br><span class="line">  <span class="function"><span class="title">insurance</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;/particulars&#x27;</span>,</span><br><span class="line">          <span class="attr">query</span>: &#123;</span><br><span class="line">            <span class="attr">id</span>: id</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 路由  </span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&#x27;/particulars&#x27;</span>,</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;particulars&#x27;</span>,</span><br><span class="line">     <span class="attr">component</span>: particulars</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>params传参 通过name引入 params对象携带参数 通过this.$route.params 获取参数  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">methods：&#123;</span><br><span class="line">  <span class="function"><span class="title">insurance</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;particulars&#x27;</span>,</span><br><span class="line">          <span class="attr">params</span>: &#123;</span><br><span class="line">            <span class="attr">id</span>: id</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 路由配置   </span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&#x27;/particulars&#x27;</span>,</span><br><span class="line">     <span class="attr">name</span>: <span class="string">&#x27;particulars&#x27;</span>,</span><br><span class="line">     <span class="attr">component</span>: particulars</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>




<h4 id="什么是-mixin"><a href="#什么是-mixin" class="headerlink" title="什么是 mixin"></a>什么是 mixin</h4><p>提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能</p>
<p>相当于扩展了父组件的对象与方法，可以理解为形成了一个新的组件</p>
<p>可以定义共用的变量，在每个组件中使用，引入组件中之后，各个变量是相互独立的，值的修改在组件中不会相互影响</p>
<h4 id="对SSR的理解"><a href="#对SSR的理解" class="headerlink" title="对SSR的理解:"></a>对SSR的理解:</h4><p>SSR就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成,然后再把html页面返回给客户端</p>
<p>优点:</p>
<p>更好的SEO</p>
<p>首屏加载速度更快</p>
<p>缺点:</p>
<p>开发条件会受到限制</p>
<p>更多的服务端负载</p>
<h4 id="服务端渲染-SSR-和预渲染-Prerendering-有什么区别"><a href="#服务端渲染-SSR-和预渲染-Prerendering-有什么区别" class="headerlink" title="服务端渲染(SSR)和预渲染(Prerendering)有什么区别"></a>服务端渲染(SSR)和预渲染(Prerendering)有什么区别</h4><p>服务端渲染:</p>
<ul>
<li><p>服务端渲染是指将客户端渲染的过程放到了服务端</p>
</li>
<li><p>服务端渲染过程: 解析执行JS =&gt; 构建HTML页面 =&gt; 输出给浏览器</p>
</li>
</ul>
<p>预渲染:</p>
<ul>
<li>直接输出HTML页面给浏览器 比服务端渲染少了解析js的步骤</li>
</ul>
<h4 id="Vue的性能优化"><a href="#Vue的性能优化" class="headerlink" title="Vue的性能优化"></a>Vue的性能优化</h4><ul>
<li><p>编码阶段</p>
<p>减少data中的数据,data中的数据都会增加getter和setter</p>
<p>v-if v-for不能连用</p>
<p>如果需要使用v-for给每项元素绑定事件时使用事件代理</p>
<p>SPA 页面采用keep-alive缓存组件</p>
<p>在更多的情况下，使用v-show替代v-if</p>
<p>key保证唯一</p>
<p>使用路由懒加载、异步组件</p>
<p>长列表滚动到可视区域动态加载</p>
<p>防抖、节流</p>
<p>第三方模块按需导入</p>
<p>图片懒加载</p>
</li>
<li><p>SEO优化</p>
<p>预渲染</p>
<p>服务端渲染SSR</p>
</li>
<li><p>打包优化</p>
<p>压缩代码</p>
<p>使用cdn加载第三方模块</p>
<p>多线程打包happypack</p>
</li>
<li><p>用户体验</p>
<p>PWA渐进式网页应用</p>
<p>在内容还没有出现之前的页面使用骨架屏填充,以免留白</p>
</li>
</ul>
<h4 id="防抖节流的区别"><a href="#防抖节流的区别" class="headerlink" title="防抖节流的区别"></a>防抖节流的区别</h4><ul>
<li><p>防抖</p>
<p>在事件触发n秒之后执行回调，如果在n秒内再次触发事件则重新计时</p>
<p>运用场景:输入框输入时</p>
</li>
<li><p>节流</p>
<p>在单位时间内多次触发只执行一次</p>
<p>运用场景:鼠标多次点击时</p>
</li>
</ul>
<h4 id="vue初始化页面闪动问题"><a href="#vue初始化页面闪动问题" class="headerlink" title="vue初始化页面闪动问题"></a>vue初始化页面闪动问题</h4><p>在css上添加[v-cloak] {    display: none;}</p>
<h4 id="methods、watch、computed的区别"><a href="#methods、watch、computed的区别" class="headerlink" title="methods、watch、computed的区别:"></a>methods、watch、computed的区别:</h4><p>methods: 适合用于业务逻辑处理, 数据不能缓存, 每次使用都会重新调用</p>
<p>watch:   当想要执行异步或者昂贵的操作以响应不断的变化时使用watch,  支持异步监听, 也可以监听路由变化, 不支持缓存, 数据变化时, 就会触发相应的操作</p>
<p>computed: 适合计算属性,  不支持异步, 可以缓存数据, 只有在相关依赖发生变化时才会重新求值</p>
<h4 id="如何实现路由懒加载"><a href="#如何实现路由懒加载" class="headerlink" title="如何实现路由懒加载:"></a>如何实现路由懒加载:</h4><ul>
<li>使用箭头函数 + import动态加载</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> List = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/components/list.vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>, <span class="attr">component</span>: List &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用箭头函数 + require动态加载</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">     <span class="attr">component</span>: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;@/components/list&#x27;</span>], resolve)</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使用webpack的require.ensure技术</li>
</ul>
<h4 id="router和-route的区别"><a href="#router和-route的区别" class="headerlink" title="$router和$route的区别"></a>$router和$route的区别</h4><p>$route是”信息路由对象”,包含path、params、query、name等路由信息参数</p>
<p>$router是”路由实例”对象包括了路由的跳转方法、钩子函数等</p>
<h4 id="hash和history的区别"><a href="#hash和history的区别" class="headerlink" title="hash和history的区别"></a>hash和history的区别</h4><ul>
<li><p>hash</p>
<p>hash模式是开发中默认的模式,它的URL带着一个#</p>
<p>hash值会出现在URL里面,但是不会出现在HTTP请求中,对后端完全没有影响</p>
</li>
<li><p>history</p>
<p>使用的是传统的路由分发模式</p>
<p>history模式需要后台配置支持</p>
</li>
</ul>
<h4 id="什么是路由导航守卫"><a href="#什么是路由导航守卫" class="headerlink" title="什么是路由导航守卫"></a>什么是路由导航守卫</h4><p>路由守卫分为 全局的、 单个路由独享的 、组件级的</p>
<p>主要用来通过跳转或取消的方式守卫导航</p>
<ul>
<li>全局前置/钩子：beforeEach、beforeResolve、afterEach</li>
<li>路由独享的守卫：beforeEnter</li>
<li>组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li>
</ul>
<h4 id="权限路由的实现"><a href="#权限路由的实现" class="headerlink" title="权限路由的实现"></a>权限路由的实现</h4><p>在定义路由规则时,在路由上标记响应的权限信息,当要跳转路由时,判断用户是否有权限访问,没有权限则跳到事先定义好的界面</p>
<p>两种方法:</p>
<ul>
<li><p>通过router.beforeEach() 路由拦截的方式实现</p>
</li>
<li><p>通过vue-router 官方提供的addRoutes()来进行动态路由注入 </p>
<p>只需要配置静态的路由表，登录、注册页，登录成功后根据后台返回的权限动态注入路由</p>
</li>
</ul>
<h4 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h4><p>app：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>home组件中又提供了<router-view></router-view>用来嵌套其他组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;user&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;h2&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">      &lt;router-view&gt;&lt;/router-view&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要在嵌套的出口中渲染组件，需要在 VueRouter 的参数中使用 children 配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/home/:id&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: Home,</span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 当 /home/:id/profile 匹配成功，</span></span><br><span class="line">          <span class="comment">// UserProfile 会被渲染在 home 的 &lt;router-view&gt; 中</span></span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: User</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 当 /home/:id/posts 匹配成功</span></span><br><span class="line">          <span class="comment">// UserPosts 会被渲染在 home 的 &lt;router-view&gt; 中</span></span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;posts&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: UserPosts</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="按钮权限控制"><a href="#按钮权限控制" class="headerlink" title="按钮权限控制"></a>按钮权限控制</h4><p>当前组件路由携带可使用的按钮权限，存入数组中，通过v-if来判断是否显示</p>
<p>登录时，单独获取整个系统的按钮权限，将获取到的所有按钮 存入一个数组中，放入全局中，然后，通过 v-if 来判断是否显示</p>
<h4 id="vue自定义指令实现权限按钮功能"><a href="#vue自定义指令实现权限按钮功能" class="headerlink" title="vue自定义指令实现权限按钮功能"></a>vue自定义指令实现权限按钮功能</h4><p>登录验证：用户登录–&gt; 验证成功–&gt; 服务器返回token–&gt; 将token存储至本地–&gt; 前端根据token调用后端接口获取（用户权限，用户信息）</p>
<p>权限验证：通过token获取对应的role–&gt; 使用自定义指令判断role是否在路由meta属性里btnPermissions数组里面–&gt; 不在就删除该按钮DOM</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xxl910/p/12706469.html">https://www.cnblogs.com/xxl910/p/12706469.html</a></p>
<h4 id="如何保存页面当前状态"><a href="#如何保存页面当前状态" class="headerlink" title="如何保存页面当前状态"></a>如何保存页面当前状态</h4><p>在组件即将销毁的声命周期中，将当前组件的状态存储在LocalStorage/SessionStorage中</p>
<p>单页面渲染 要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态</p>
<p>用keep-alive缓存组件</p>
<h4 id="什么是keep-alive"><a href="#什么是keep-alive" class="headerlink" title="什么是keep-alive"></a>什么是keep-alive</h4><p> keep-alive用来缓存组件,避免多次加载相应的组件,减少性能消耗</p>
<p>如果需要在组件切换的时候,保存一些组件的状态防止多次渲染,可以用keep-alive组件包裹需要保存的组件</p>
<h4 id="nextTick原理"><a href="#nextTick原理" class="headerlink" title="$nextTick原理"></a>$nextTick原理</h4><p>本质是对JavaScript执行原理EventLoop的应用</p>
<p>nextTick的核心是利用了Promise、MutationObserver、setImmediate、setTimeout的原生js方法来模拟微/宏任务的实现</p>
<p>keep-alive 只对第一个组件有效</p>
<p>$nextTick()方法的作用：当页面上的元素被重新渲染后，才会执行回调函数中的代码。</p>
<h4 id="什么情况使用nextTick"><a href="#什么情况使用nextTick" class="headerlink" title="什么情况使用nextTick"></a>什么情况使用nextTick</h4><p>在数据变化后执行的某个操作,需要使用随数据变化而变化的DOM结构时,就需要将这个操作放在nextTick的回调函数中</p>
<p>在creatd()钩子进行DOM操作,一定要放在nextTick()回调函数中</p>
<h4 id="Vue-data中某一个属性值发生变化后-视图会立即同步执行重新渲染吗"><a href="#Vue-data中某一个属性值发生变化后-视图会立即同步执行重新渲染吗" class="headerlink" title="Vue data中某一个属性值发生变化后,视图会立即同步执行重新渲染吗?"></a>Vue data中某一个属性值发生变化后,视图会立即同步执行重新渲染吗?</h4><p>不会立即同步执行重新渲染</p>
<p>Vue更新DOM时是异步执行的,只要侦听到数据变化,Vue将开启一个队列,并缓冲在同一事件循环中发生的所有数据变更</p>
<p>如果watcher被多次触发,只会被推入队列一次,在下一个事件循环tick中,Vue刷新队列并执行已去重的工作</p>
<h4 id="Vue-SPA与MPA的区别"><a href="#Vue-SPA与MPA的区别" class="headerlink" title="Vue SPA与MPA的区别"></a>Vue SPA与MPA的区别</h4><ul>
<li><p>概念</p>
<p>SPA单页面应用,只有一个主页面的应用,只需要加载一次js、css等相关资源,所有内容都在主页面,单页面应用跳转,就是切换相关组件,仅刷新局部资源,  相对服务器压力小 , 前后端职责分离，架构清晰 </p>
<p>MPA多页面应用,拥有多个独立页面的应用,每个页面需要重复加载js、css相关资源,多页面应用跳转,需要刷新整页资源</p>
</li>
<li><p>区别</p>
<p>SPA只有一个主页面和许多模块的组件 MPA有多个完整页面</p>
<p>SPA页面切换快 MPA页面切换慢</p>
<p>SPA只需加载一次公用资源 MPA每个页面都需加载自己的公用资源</p>
<p>SPA不利于SEO(搜索引擎优化) MPA适用于SEO要求较高的应用</p>
</li>
</ul>
<h4 id="Vue在哪个生命周期执行异步操作"><a href="#Vue在哪个生命周期执行异步操作" class="headerlink" title="Vue在哪个生命周期执行异步操作"></a>Vue在哪个生命周期执行异步操作</h4><p>可以在created和beforeMount、mounted中执行 ，因为data此时已经创建,可以将服务端返回的数据进行赋值</p>
<p>但是推荐在created中执行异步操作，获取数据快，用户体验好，服务器渲染不支持beforeMount、mounted</p>
<h4 id="什么时候需要使用beforeDestory"><a href="#什么时候需要使用beforeDestory" class="headerlink" title="什么时候需要使用beforeDestory"></a>什么时候需要使用beforeDestory</h4><p>此时DOM还没有销毁</p>
<p>1、当前页面使用了$on方法,需要在组件解绑前销毁</p>
<p>2、清除自己定义的定时器</p>
<p>3、解除事件的绑定</p>
<h4 id="什么时候使用destoryed"><a href="#什么时候使用destoryed" class="headerlink" title="什么时候使用destoryed"></a>什么时候使用destoryed</h4><p>移除监听事件</p>
<p>移除对dom的操作</p>
<p>销毁VueX中存储的数据，否则页面不刷新，在页面刚渲染时，一直展示的是上次的数据</p>
<h4 id="什么是Vuex"><a href="#什么是Vuex" class="headerlink" title="什么是Vuex"></a>什么是Vuex</h4><p>vuex是一种全局状态管理模式 每个vuex都有一个核心store(仓库) vuex的状态存储是响应式的</p>
<h4 id="vuex的五大核心"><a href="#vuex的五大核心" class="headerlink" title="vuex的五大核心"></a>vuex的五大核心</h4><p>  state: 存储数据,存储状态</p>
<p>  getter: 可以认为是store的计算属性,它的返回值会根据它的依赖缓存起来</p>
<p>  mutation: 提交更改数据的方法 只能进行同步操作</p>
<p>  action: 像一个装饰器 包裹mutations 使之可以异步</p>
<p>  module: 模块化Vuex</p>
<h4 id="mutation和action的区别"><a href="#mutation和action的区别" class="headerlink" title="mutation和action的区别"></a>mutation和action的区别</h4><p>mutation中的操作是一系列同步函数,用于修改state中的变量的状态 </p>
<p>action中可以包含任意异步操作 action提交的是mutation,而不是直接修改状态</p>
<h4 id="vuex和localStorage的区别"><a href="#vuex和localStorage的区别" class="headerlink" title="vuex和localStorage的区别"></a>vuex和localStorage的区别</h4><p>vuex:</p>
<ul>
<li><p>存储在内存当中 页面刷新就存储的值消失</p>
</li>
<li><p>用于组件传值</p>
</li>
<li><p>vuex存储值是响应式的</p>
</li>
</ul>
<p>localStorage:</p>
<ul>
<li><p>存储在本地,永久保存</p>
</li>
<li><p>用于页面之间传值</p>
</li>
</ul>
<h4 id="loacalStorage和sessionStorage的区别"><a href="#loacalStorage和sessionStorage的区别" class="headerlink" title="loacalStorage和sessionStorage的区别"></a>loacalStorage和sessionStorage的区别</h4><p>localStorage存储的值是永久的</p>
<p>sessionStorage存储的值在当前窗口关闭后就会消失</p>
<p>相同浏览器的不同页面间可以共享相同的 localStorage</p>
<p>不同页面或标签页间无法共享sessionStorage的信息</p>
<h4 id="Vue3-0的更新"><a href="#Vue3-0的更新" class="headerlink" title="Vue3.0的更新"></a>Vue3.0的更新</h4><p>消除了Vue2中Object.defineProperty的很多限制</p>
<p>带来了基于代理Proxy的observer实现</p>
<p>检测属性的添加和删除</p>
<p>支持Map、Set、WeakMap 和 WeakSet</p>
<p>3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易</p>
<p>3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能 </p>
<h4 id="有哪些常见的Loader？他们是解决什么问题的？"><a href="#有哪些常见的Loader？他们是解决什么问题的？" class="headerlink" title="有哪些常见的Loader？他们是解决什么问题的？"></a>有哪些常见的Loader？他们是解决什么问题的？</h4><p>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</p>
<p>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</p>
<h4 id="uni-app的bug"><a href="#uni-app的bug" class="headerlink" title="uni-app的bug"></a>uni-app的bug</h4><p>无法覆盖uni-app提供的组件的样式 直接重写不会生效</p>
<p>ios真机下键盘遮挡住弹框底部部分内容 </p>
<p>取消了顶部导航栏，出现页面和手机基本信息(信号，时间等)重合</p>
<p>input框被输入键盘覆盖 自身有一个属性设置键盘到输入框的距离</p>
<ul>
<li>使用vue-cli创建的uni-app的静态资源必须存放在static文件夹下</li>
<li>vue父子组件数据单向流的原则</li>
<li>使用静态资源图片名称不允许包含中文</li>
<li>uniapp使用v-show在微信小程序端不能使用list.length没有效果</li>
<li>微信小程序pages.json里面的tabbar两个状态的文件一定要文件存在,否者小程序端会编译失败</li>
<li>组件内引入图片要使用绝对路径</li>
<li>用tap事件代替click事件</li>
</ul>
<h4 id="项目中遇到的难点"><a href="#项目中遇到的难点" class="headerlink" title="项目中遇到的难点"></a>项目中遇到的难点</h4><p>1、mounted钩子函数中请求数据导致页面闪屏问题</p>
<p>​    解决：其实就是加载时机问题，放在created里会比mounted触发早一点，如果在页面挂载完之前请求完成的话就不会看到闪屏了</p>
<p>2、IE9中template标签使用问题</p>
<p>​    解决：之前在tr标签里面用template标签包裹td标签，出现了比较严重的UI错乱，所以。。IE9不能在tr标签中使用template标签</p>
<p>3、el-table用v-if隐藏显示列和预期不符问题</p>
<p>​    解决：给el-table-column加一个key属性，:key=”Math.random()”或者其他的，确保每列的key值不同就可以了</p>
<p>4、在使用el-table的时候有的时候需要对表格中的数据做处理，需要用到filter，虽然官方也有提供过滤的方法（filter-method），但是还是用自定义列，然后用filter复用性好一些</p>
<p>5、在element中使用el-input实现点击显示输入框，失去焦点时生成新的tag标签，出现两行数据下的输入框会同时修改的bug，因此要为他们单独设置自己的false和输入框的值</p>
<p><img src="C:\Users\pc\AppData\Roaming\Typora\typora-user-images\1626541015762.png" alt="1626541015762"></p>
<p><img src="C:\Users\pc\AppData\Roaming\Typora\typora-user-images\1626540686684.png" alt="1626540686684"></p>
<h4 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h4><h1 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h1><h4 id="登录授权"><a href="#登录授权" class="headerlink" title="登录授权"></a>登录授权</h4><ul>
<li><p>小程序端调用wx.login()，获取登录凭证code，并wx.request提交code给己方服务器</p>
</li>
<li><p>服务器提交Appid + appSecret + code到微信方服务器，获取session_key &amp; openid</p>
</li>
<li><p>服务器根据session_key &amp; openid生成3rd_session，并返回3rd_session到小程序端</p>
</li>
<li><p>小程序端wx.setStorage存储3rd_session在后续用户操作需要凭证时，附带该参数</p>
</li>
<li><p>小程序端wx.getUserInfo获取用户信息 + wx.getStorage获取3rd_session数据后，一并wx.request提交给己方服务器</p>
</li>
<li><p>服务器SQL用户数据信息更新</p>
</li>
<li><p><img src="C:\Users\pc\AppData\Roaming\Typora\typora-user-images\1626656270605.png" alt="1626656270605"></p>
<p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dashucoding/p/9917371.html">https://www.cnblogs.com/dashucoding/p/9917371.html</a></p>
</li>
</ul>
<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h4 id="什么react"><a href="#什么react" class="headerlink" title="什么react"></a>什么react</h4><p>react是一个构建用户界面的JavaScript库</p>
<h4 id="React的生命周期"><a href="#React的生命周期" class="headerlink" title="React的生命周期"></a>React的生命周期</h4><p>组件挂载阶段:</p>
<ul>
<li><p>constructor</p>
</li>
<li><p>getDerivedStateFromProps</p>
</li>
<li><p>render</p>
</li>
<li><p>componentDidMount</p>
</li>
</ul>
<p>组件更新阶段:</p>
<ul>
<li><p>shouldComponentUpdate</p>
</li>
<li><p>getSnapshotBeforeUpdate</p>
</li>
<li><p>componentDidUpdate</p>
</li>
</ul>
<p>组件卸载阶段:</p>
<ul>
<li>componentWillUnmount() </li>
</ul>
<h4 id="有状态组件和无状态组件"><a href="#有状态组件和无状态组件" class="headerlink" title="有状态组件和无状态组件"></a>有状态组件和无状态组件</h4><p>有状态组件</p>
<ul>
<li><p>是类组件</p>
</li>
<li><p>有继承</p>
</li>
<li><p>可以使用this</p>
</li>
<li><p>可以是有react的生命周期</p>
</li>
<li><p>使用较多,会频发触发声明周期钩函数,影响性能</p>
</li>
<li><p>内部使用state,维护自身变化,根据外部组件传入的 props 和自身的 state进行渲染</p>
</li>
</ul>
<p>无状态组件</p>
<ul>
<li><p>不依赖自身的state</p>
</li>
<li><p>可以是类组件或函数组件</p>
</li>
<li><p>完全可以避免this关键字</p>
</li>
<li><p>有更高的性能</p>
</li>
<li><p>内部不维护state,只根据外部传入的props进行渲染,props改变时,组件重新渲染</p>
</li>
</ul>
<h4 id="组件通信的方式-1"><a href="#组件通信的方式-1" class="headerlink" title="组件通信的方式"></a>组件通信的方式</h4><p>父传子: 父组件通过props向子组件传递信息</p>
<p>子传父: props+回调函数的方式</p>
<p>非父子组件传递: </p>
<ul>
<li><p>使用props,每一层组件都要上传一个props</p>
</li>
<li><p>使用context,context相当于一个容器,将要通信的内容放入context中,别的组件可以随意取用</p>
</li>
</ul>
<p>全局状态管理⼯具: 借助Redux或者Mobx等全局状态管理工具进行通信</p>
<h4 id="PureComponent和Component的区别是什么"><a href="#PureComponent和Component的区别是什么" class="headerlink" title="PureComponent和Component的区别是什么"></a>PureComponent和Component的区别是什么</h4><p>PureComponent会自动执行shouldComponentUpdate函数,通过shallowEqual的浅对比,实现react性能优化</p>
<p>Component必须通过自己调用shouldComponentUpdate来实现react组件的优化</p>
<h1 id="JAVASCRIPT"><a href="#JAVASCRIPT" class="headerlink" title="JAVASCRIPT"></a>JAVASCRIPT</h1><h4 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h4><p>将特定功能的代码抽取出来,使之成为程序中的一个独立实体</p>
<h4 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h4><p>箭头函数使用箭头定义,普通函数没有</p>
<p>箭头函数比普通函数更简洁</p>
<p>箭头函数的参数可以设置默认值</p>
<p>箭头函数不绑定arguments，取而代之用rest参数…解决</p>
<p>箭头函数没有自己的this,它的this是捕获上下文的this当做自己的this,它的this指向不能改变</p>
<h4 id="什么是事件循环"><a href="#什么是事件循环" class="headerlink" title="什么是事件循环:"></a>什么是事件循环:</h4><p>同步和异步任务分别进入不同的执行环境,同步进入主线程,异步进入任务队列,主线程任务执行完毕为空,会去任务队列读取对应的任务,推入主线程执行.这个过程不断重复就是事件循环</p>
<ul>
<li><p>宏任务:</p>
<p>宏任务主要包含script、setTimeout、setlnterval、I/O、UI交互事件、setImmediate(Node.js环境)</p>
</li>
<li><p>微任务:</p>
<p>微任务只要包含Promise、MutationObserver、process.nextTick(Node.js环境)</p>
</li>
</ul>
<h4 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式:"></a>继承的方式:</h4><p>寄生组合继承</p>
<p>原型链继承</p>
<p>组合继承</p>
<p>es6中class类的extends关键字继承</p>
<h4 id="回调函数、Promise面试七连"><a href="#回调函数、Promise面试七连" class="headerlink" title="回调函数、Promise面试七连:"></a>回调函数、Promise面试七连:</h4><ul>
<li><p>什么是回调函数:</p>
<p>一个函数把另一个函数当做参数使用,调用的同时传递数据</p>
</li>
</ul>
<ul>
<li><p>回调函数使用场景:</p>
<p>一般用于ajax请求,或者不能立即获取数据</p>
</li>
</ul>
<ul>
<li><p>回调函数的缺陷:</p>
<p>多层嵌套会产生回调地狱,不利于代码的维护</p>
</li>
</ul>
<ul>
<li><p>如何解决回调地狱:</p>
<p>使用es6中的Promise</p>
</li>
</ul>
<ul>
<li><p>Promise的特性:</p>
<p>Promise是一个对象也是一个构造函数,需要被实例化</p>
<p>Promise有三种状态: pending(进行中) fulfilled(已成功) rejected(已失败)</p>
<p>Promise需要传递一个箭头函数,函数中有两个参数reslove,rejected</p>
<p>resolve执行成功,rejected执行失败</p>
<p>Promise的原型有then方法、catch方法、finally方法、all方法、rise方法</p>
<p>finally方法不管Promise状态如何都会执行</p>
</li>
</ul>
<ul>
<li><p>Promise的缺陷:</p>
<p>代码量较多</p>
</li>
</ul>
<ul>
<li><p>如何解决Promise缺陷:</p>
<p>使用es7的async await</p>
<p>使用async await可以使异步像同步一样执行</p>
<p>async返回的是一个promise对象</p>
</li>
</ul>
<h4 id="如何中断Promise的链式编程"><a href="#如何中断Promise的链式编程" class="headerlink" title="如何中断Promise的链式编程"></a>如何中断Promise的链式编程</h4><p>方式1: 条件成立后,通过throw抛出异常中断</p>
<p>方式2: 条件成立后,通过Promise.reject()中断</p>
<h4 id="get请求与post请求的区别"><a href="#get请求与post请求的区别" class="headerlink" title="get请求与post请求的区别"></a>get请求与post请求的区别</h4><p>get请求只能进行url编码,post请求支持多种编码方式</p>
<p>get请求会产生历史记录,post请求不会</p>
<p>get请求更快,post请求更安全</p>
<p>get请求参数通过url传递,post请求放在Request body中</p>
<p>get请求传递参数有长度限制,post没有</p>
<p>get请求只接受字符串,post请求没有限制</p>
<h4 id="http协议的特点"><a href="#http协议的特点" class="headerlink" title="http协议的特点"></a>http协议的特点</h4><p>支持客户端/服务器模式</p>
<p>简单快速: 客户向服务器请求服务时，只需传送请求方法和路径</p>
<p>灵活: HTTP允许传输任意类型的数据对象</p>
<p>无连接: 限制每次连接只处理一个请求，服务器处理完客户请求并得到响应后,即断开连接</p>
<p>无状态: 无状态是值协议对事务处理没有记忆能力</p>
<h4 id="es6的新增"><a href="#es6的新增" class="headerlink" title="es6的新增"></a>es6的新增</h4><ul>
<li><p>字符串扩展</p>
<p>新增字符串模板</p>
</li>
</ul>
<ul>
<li><p>块级作用域</p>
<p>let、const</p>
<p>let const 不存在变量提升</p>
<p>const声明的是一个常量,值不能被修改,const声明时必须赋值</p>
<p>const和let不允许重复声明变量</p>
<p><img src="C:\Users\pc\AppData\Roaming\Typora\typora-user-images\1626673442632.png" alt="1626673442632"></p>
</li>
</ul>
<ul>
<li><p>函数扩展</p>
<p>新增箭头函数</p>
<p>参数可以设置默认值</p>
</li>
</ul>
<ul>
<li><p>数组扩展</p>
<p>Array.from() 将伪数组变成数组</p>
<p>Array.of() 将一组值转换成数组</p>
<p>find()  找出第一个符合条件的数组成员 </p>
<p>findIndex() 找出第一个符合条件的数组成员的下标</p>
<p>for…of 数组遍历</p>
<p>reduce  让数组的前后两项进行某种计算，返回最终操作的结果 </p>
</li>
<li><p>扩展运算符 </p>
<p>可以将一个数组转为用逗号分隔的参数序列<br>复制数组<br>合并数组<br>扩展运算符和解构赋值结合,用于生成数组<br>将字符串转为真正的数组</p>
</li>
<li><p>对象扩展</p>
<p>属性名表达式</p>
<p>解构赋值</p>
<p>super关键字 指向当前对象的原型对象</p>
</li>
<li><p>支持class语法</p>
</li>
<li><p>Promise</p>
</li>
</ul>
<h4 id="数组去重的方法"><a href="#数组去重的方法" class="headerlink" title="数组去重的方法"></a>数组去重的方法</h4><p>双层循环，外层循环元素，内层循环时比较值 如果有相同的值则跳过，不相同则push进新的数组</p>
<p>双层循环，外层循环元素，内层循环时比较值 值相同时，则删去这个值 删除元素之后 需要将数组的长度也减1</p>
<p>利用es6的set成员的值都是唯一的特性 利用Arra.from将Set转换成数组</p>
<p>利用indexOf以及forEach</p>
<p>数组递归去重</p>
<p>利用对象的属性不能相同的特点进行去重</p>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>在let、const命令声明变量之前,该变量都是不可用的,该变量是不可用的</p>
<h4 id="new操作符做了什么"><a href="#new操作符做了什么" class="headerlink" title="new操作符做了什么"></a>new操作符做了什么</h4><p>创建一个对象</p>
<p>将构造函数的作用域赋给新对象</p>
<p>构造函数的this指向该对象,执行构造函数</p>
<p>返回新对象</p>
<h4 id="对rest参数的理解"><a href="#对rest参数的理解" class="headerlink" title="对rest参数的理解:"></a>对rest参数的理解:</h4><p>以”…”开头是一个真正的数组</p>
<p>它可以把一个分离的参数序列整合成一个数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mutiple</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args)</span><br><span class="line">&#125;</span><br><span class="line">mutiple(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>rest参数的引入减少了样式代码</p>
<p>rest参数可以被解构</p>
<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。</p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>原型链就是一种查找的过程,通过指针不断往上一层的原型对象查找的过程,就叫做原型链.如果一直往上找没有就会找到null</p>
<h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><p>是一种创建交互式网页应用的网页开发技术,是一种能够实现局部网页刷新功能的技术</p>
<h4 id="JSONP和JSON的区别"><a href="#JSONP和JSON的区别" class="headerlink" title="JSONP和JSON的区别"></a>JSONP和JSON的区别</h4><p>JSONP是一种非官方的跨域解决方案,利用了script的src不受限制的访问外部资源,结合callback回调函数拿到数据</p>
<p>JSON是一种轻量级的数据结构,能跨平台进行网络传输,能做配置文件</p>
<h4 id="什么是oop"><a href="#什么是oop" class="headerlink" title="什么是oop"></a>什么是oop</h4><p>oop是一种编程思想,又叫做面向对象编程</p>
<p>三大特性:</p>
<ul>
<li><p>继承 子类拥有父类的属性和方法</p>
</li>
<li><p>封装 将相同的属性和方法提取成一个类</p>
</li>
<li><p>多态 </p>
<ul>
<li><p>重写 子类重写父类的组件和方法</p>
</li>
<li><p>重载 在同一个类中,同名不同参,js没有重载</p>
</li>
</ul>
</li>
</ul>
<h4 id="对闭包的理解"><a href="#对闭包的理解" class="headerlink" title="对闭包的理解"></a>对闭包的理解</h4><p>闭包就是函数嵌套函数,内部函数可以引用外部函数的参数和变 量,参数和变量不会被垃圾回收机制所回收</p>
<ul>
<li><p>优点:</p>
<p>使变量长期驻扎在内存当中,实现缓存</p>
<p>避免全局变量污染</p>
<p>在函数外部能够访问到函数内部的变量 </p>
</li>
<li><p>缺点:</p>
<p>由于闭包会使函数的变量长期驻扎在内存当中,会导致内存消耗过大,影响浏览器的性能,在ie中会导致内存泄漏</p>
</li>
</ul>
<h4 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h4><ul>
<li><p>标记清除:</p>
<p>js会对变量做一个yes或no的标记,供js引擎处理,当变量在某个环境使用时标记为yes,超出该环境时标记为no,js会在一定时间内来扫描,对标记为no的变量进行释放</p>
</li>
<li><p>引用计数:</p>
<p>对于引用类型的变量,采用引用计数的回收机制,当一个引用类型的变量赋值给另一个变量时,引用计数+1,当其中有一个变量不再等于值时,引用计数-1,如果引用计数为0,js引擎会将其释放</p>
</li>
</ul>
<h4 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h4><p>函数自己调用自己,有一个临界点,就是结束条件</p>
<h4 id="递归的使用场景"><a href="#递归的使用场景" class="headerlink" title="递归的使用场景"></a>递归的使用场景</h4><p>快速排序使用递归</p>
<p>nodejs磁盘文件的遍历</p>
<p>管理系统的权限菜单栏</p>
<p>对象的深拷贝</p>
<h4 id="对象的深拷贝和浅拷贝"><a href="#对象的深拷贝和浅拷贝" class="headerlink" title="对象的深拷贝和浅拷贝"></a>对象的深拷贝和浅拷贝</h4><p>浅拷贝:</p>
<ul>
<li><p>浅拷贝只会将对象的各个属性进行依次复制，并不会进行递归复制</p>
</li>
<li><p>如果拷贝后的对象发生变化,原对象也会发生变化</p>
</li>
</ul>
<p>深拷贝:</p>
<ul>
<li><p>不仅将原对象的各个属性逐个复制，而且将原对象各个属性所包含的对象也依次采用深拷贝的方法递归复制到新对象上</p>
</li>
<li><p>拷贝后的对象不会影响原来的对象</p>
</li>
</ul>
<h4 id="深拷贝方法"><a href="#深拷贝方法" class="headerlink" title="深拷贝方法"></a>深拷贝方法</h4><ul>
<li><p>如果拷贝的对象是json格式的数据可以使用JSON.stringify()和JSON.parse()</p>
<p>缺点:</p>
<ul>
<li><p>如果不是json格式会报错 </p>
</li>
<li><p>不能拷贝对象属性为函数的 </p>
</li>
<li><p>不能拷贝对象属性值为undefine </p>
</li>
<li><p>不能拷贝正则 </p>
</li>
<li><p>不能实现对对象的循环引用</p>
</li>
</ul>
</li>
<li><p>使用递归的方式遍历对象把它复制到一个新的对象,改变它的key和value,用一个崭新的对象替代它</p>
</li>
</ul>
<h4 id="浅拷贝方法"><a href="#浅拷贝方法" class="headerlink" title="浅拷贝方法"></a>浅拷贝方法</h4><ul>
<li><p>object.assign </p>
</li>
<li><p>es6扩展运算符</p>
</li>
</ul>
<h4 id="什么是http协议"><a href="#什么是http协议" class="headerlink" title="什么是http协议"></a>什么是http协议</h4><p>超文本传输协议HyperText Transfer Protocol</p>
<p>就是客户端和服务端进行数据传输的一种规则</p>
<h4 id="http协议的五大特点"><a href="#http协议的五大特点" class="headerlink" title="http协议的五大特点"></a>http协议的五大特点</h4><p>支持客户/服务器模式</p>
<p>通信速度快</p>
<p>http允许传输任意类型的数据对象</p>
<p>无连接 限制每次只处理一个请求</p>
<p>无状态 对事务处理没有记忆能力</p>
<h4 id="浏览器输入url后的流程"><a href="#浏览器输入url后的流程" class="headerlink" title="浏览器输入url后的流程"></a>浏览器输入url后的流程</h4><p>将地址发送到DNS服务器</p>
<p>DNS进行域名解析</p>
<p>获取域名所对应的web服务器地址</p>
<p>建立TCP连接</p>
<p>浏览器发送http请求</p>
<p>服务器处理请求并响应结果</p>
<p>浏览器解析HTML</p>
<p>关闭TCP连接</p>
<p>浏览器布局渲染</p>
<h4 id="浏览器渲染页面的原理及流程"><a href="#浏览器渲染页面的原理及流程" class="headerlink" title="浏览器渲染页面的原理及流程"></a>浏览器渲染页面的原理及流程</h4><p>根据html文件构建DOM树和CSS规则树</p>
<p>附着合成构建渲染树</p>
<p>页面渲染完成后显示页面</p>
<h4 id="关于浏览器预检-options-请求"><a href="#关于浏览器预检-options-请求" class="headerlink" title="关于浏览器预检(options)请求"></a>关于浏览器预检(options)请求</h4><p>在非简单请求且跨域的情况下，浏览器会发起options预检请求</p>
<p>常见的复杂请求</p>
<ul>
<li><p>请求方法为PUT或DELETE</p>
</li>
<li><p>Content-Type字段类型为application/json</p>
</li>
<li><p>添加额外的http header 比如access_token</p>
</li>
</ul>
<p>在跨域的情况下，非简单请求会先发起一次空body的options请求，称为”预检”请求，用于向服务器请求权限信息，等预检请求被成功响应后，才发起真正的http请求</p>
<h4 id="http1-0和http2-0的区别"><a href="#http1-0和http2-0的区别" class="headerlink" title="http1.0和http2.0的区别"></a>http1.0和http2.0的区别</h4><ul>
<li><p>http1.0</p>
<p>无状态、无连接</p>
<p>浏览器每次请求都需要与服务器建立一个TCP连接,服务器处理完成后立即断开TCP连接</p>
</li>
<li><p>http2.0</p>
<p>二进制分帧</p>
<ul>
<li>HTTP/2引入二进制数据帧和流的概念，其中针对数据进行顺序标识</li>
</ul>
<p>多路复用（或连接共享）</p>
<ul>
<li><p>所有的HTTP2.0通信都在一个TCP连接上完成，这个连接可以承载任意数量的双向数据流</p>
</li>
<li><p>一个request对应一个id,这样一个连接可以有多个request,服务器可以根据请求的id进行处理</p>
</li>
</ul>
</li>
</ul>
<p>头部压缩</p>
<ul>
<li><p>HTTP2.0使用encoder来减少需要传输的header大小</p>
<ul>
<li> 避免了重复header的传输 </li>
</ul>
<p>服务器推送</p>
<ul>
<li>服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求</li>
</ul>
</li>
</ul>
<h4 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h4><h4 id="bind、apply、call"><a href="#bind、apply、call" class="headerlink" title="bind、apply、call"></a>bind、apply、call</h4><ul>
<li>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li>
<li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li>
<li>bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li>
</ul>
<h4 id="如何实现0-1-0-2-0-3"><a href="#如何实现0-1-0-2-0-3" class="headerlink" title="如何实现0.1+0.2=0.3"></a>如何实现0.1+0.2=0.3</h4><p>一个直接的解决方法就是<strong>设置一个误差范围</strong>，通常称为“机器精度”。</p>
<p>对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是2-52，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 ===0.3</p>
<h4 id="for…in和for…of的区别"><a href="#for…in和for…of的区别" class="headerlink" title="for…in和for…of的区别"></a>for…in和for…of的区别</h4><ul>
<li><p>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</p>
</li>
<li><p>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</p>
</li>
<li><p>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值</p>
<p><strong>总结：</strong> for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</p>
</li>
</ul>
<h4 id="什么是-DOM-和-BOM？"><a href="#什么是-DOM-和-BOM？" class="headerlink" title="什么是 DOM 和 BOM？"></a>什么是 DOM 和 BOM？</h4><ul>
<li>DOM：文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</li>
<li>BOM：浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。</li>
<li>并且 DOM 的最根本的对象 document 对象是 BOM 的 window 对象的子对象。</li>
</ul>
<h4 id="ES6模块与CommonJS模块的异同"><a href="#ES6模块与CommonJS模块的异同" class="headerlink" title="ES6模块与CommonJS模块的异同"></a>ES6模块与CommonJS模块的异同</h4><h4 id="判断一个对象是否属于某个类"><a href="#判断一个对象是否属于某个类" class="headerlink" title="判断一个对象是否属于某个类"></a>判断一个对象是否属于某个类</h4><ul>
<li>instanceof </li>
<li>constructor </li>
<li>Object.prototype.toString() </li>
</ul>
<h4 id="null是什么类型的"><a href="#null是什么类型的" class="headerlink" title="null是什么类型的"></a>null是什么类型的</h4><p>console.log(typeof null);            // object</p>
<h4 id="判断数据类型的方法-他们的区别"><a href="#判断数据类型的方法-他们的区别" class="headerlink" title="判断数据类型的方法  他们的区别"></a>判断数据类型的方法  他们的区别</h4><ul>
<li><p><strong>（1）typeof</strong>：判断基本类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object    </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中数组、对象、null都会被判断为object，其他判断都正确。</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>（2）instanceof</strong>：判断引用类型</p>
<p><code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false </span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>（3） constructor</strong>：</p>
<p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了</p>
</li>
<li><p>**（4）Object.prototype.toString.call()**：</p>
<p>使用 Object 对象的原型方法 toString 来判断数据类型</p>
</li>
</ul>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h4 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h4><p>块级格式化上下文</p>
<p>BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品</p>
<h4 id="怎么创建BFC"><a href="#怎么创建BFC" class="headerlink" title="怎么创建BFC"></a>怎么创建BFC</h4><p>使用浮动布局 绝对定位 </p>
<p>overflow不为visible</p>
<h4 id="盒模型的理解"><a href="#盒模型的理解" class="headerlink" title="盒模型的理解"></a>盒模型的理解</h4><p>盒模型都是由四个部分组成的，分别是margin、border、padding和content</p>
<p>标准盒模型的width和height属性的范围只包含了content</p>
<p>IE盒模型的width和height属性的范围包含了border、padding和content</p>
<h4 id="css3新增特性"><a href="#css3新增特性" class="headerlink" title="css3新增特性"></a>css3新增特性</h4><p>圆角border-radius</p>
<p>@font-size加载字体样式</p>
<p>文字渲染</p>
<p>多列布局column-count</p>
<p>渐变效果gradient</p>
<p>阴影效果图</p>
<p>多背景图片</p>
<p>动画效果animation</p>
<h4 id="两栏式布局"><a href="#两栏式布局" class="headerlink" title="两栏式布局"></a>两栏式布局</h4><p>左边一栏宽度固定，右边一栏宽度自适应</p>
<h4 id="三栏式布局"><a href="#三栏式布局" class="headerlink" title="三栏式布局"></a>三栏式布局</h4><p>左右两栏宽度固定，中间自适应</p>
<h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p>relative：元素的定位相对于元素自身位置，不会影响其他元素，不脱离文档流</p>
<p>fixed：元素的定位相对于window边界，会导致其他元素位置的变化</p>
<p>absolute：脱离文档流</p>
<h4 id="absolute和fixed的区别"><a href="#absolute和fixed的区别" class="headerlink" title="absolute和fixed的区别"></a>absolute和fixed的区别</h4><p>共同点：</p>
<p>改变行内元素的呈现方式（inline-block）</p>
<p>是元素脱离普通文档流，不占据空间</p>
<p>覆盖非定位文档元素</p>
<p>不同点：</p>
<p>absolute与fixed的根元素不同，absolute根元素可以设置，fixed的根元素为浏览器</p>
<p>在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置</p>
<h4 id="css优化"><a href="#css优化" class="headerlink" title="css优化"></a>css优化</h4><ul>
<li><p>加载性能</p>
<p>将写好的css进行打包压缩</p>
<p>减少使用@import,尽量用link 后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载</p>
</li>
<li><p>选择器性能</p>
<p>避免使用通配规则</p>
<p>尽量少用后代选择器</p>
</li>
<li><p>渲染性能</p>
<p>慎重使用 定位 浮动</p>
<p>减少页面的重绘、重排</p>
<p>去除空规则</p>
<p>属性值为0.几时可以去掉0</p>
</li>
<li><p>可维护性、健壮性</p>
<p>将有相同属性的样式抽离,通过类名使用</p>
<p>样式与内容分离 将css代码定义在外部文件中</p>
</li>
</ul>
<h4 id="如何解决1px问题"><a href="#如何解决1px问题" class="headerlink" title="如何解决1px问题"></a>如何解决1px问题</h4><p>1、直接写0.5px</p>
<p>2、伪元素先放大后缩小</p>
<p>3、viewport缩放</p>
<h4 id="设置小于12px的字体"><a href="#设置小于12px的字体" class="headerlink" title="设置小于12px的字体"></a>设置小于12px的字体</h4><p>谷歌浏览器：加样式前缀-webkite-</p>
<p>css3：-webkit-transform:scale(0.5)</p>
<p>使用图片</p>
<h4 id="高度塌陷"><a href="#高度塌陷" class="headerlink" title="高度塌陷"></a>高度塌陷</h4><ul>
<li><p>兄弟之间</p>
<p>两个margin值中取最大的</p>
<p>只给一个盒子添加margin值</p>
</li>
<li><p>父子之间</p>
</li>
</ul>
<p>当子元素有浮动并且父元素没有高度的情况下，父元素会出现高度为零的情况。</p>
<p>方法一：给父元素写固定高度</p>
<p>方法二：给外部的父盒子也添加浮动，让其也脱离标准文档流</p>
<p>方法三：给父元素添加声明overflow:hidden;(触发一个BFC)</p>
<p>方法四：在浮动元素下方添加空div,并给该元素设置以下属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.空div的类名&#123;</span><br><span class="line">                <span class="attr">clear</span>:both; </span><br><span class="line">                height:<span class="number">0</span>; </span><br><span class="line">                overflow:hidden;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>方法五： 给父元素添加display：table;</p>
<p>方法六：万能清除浮动法(推荐使用!!!)</p>
<p>​    在父元素中内容的最后添加一个伪元素，具体设置样式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.box:after&#123;</span><br><span class="line">				<span class="attr">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">				clear: both;</span><br><span class="line">				display: block;</span><br><span class="line">				height: <span class="number">0</span>;</span><br><span class="line">				overflow: hidden;</span><br><span class="line">				visibility: hidden;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>





<h4 id="rfc"><a href="#rfc" class="headerlink" title="rfc"></a>rfc</h4><p>react中创建组件的方式之一</p>
<p>ES5 原生方式 React.createClass // RFC</p>
<p>React.createClass会自绑定函数方法，导致不必要的性能开销，增加代码过时的可能性。</p>
<h4 id="移动端适配方案"><a href="#移动端适配方案" class="headerlink" title="移动端适配方案"></a>移动端适配方案</h4><ul>
<li>早期网页设计采用<strong>静态布局</strong>，通过<code>&lt;meta&gt;</code>标签中的<code>applicable-device</code>应用设备标识识别移动设备，即<code>&lt;meta name = &#39;applicable-device&#39; content = &#39;mobile&#39;&gt;</code>，在<code>&lt;meta&gt;</code>标签中的<code>viewport</code>标签中设置<code>width</code>，通过<code>js</code>动态修改标签的<code>initial-scale</code>使得页面等比缩放，刚好占满整个屏幕</li>
<li><strong>流式布局</strong>，使用百分比<code>%</code>定义宽度，高度使用<code>px</code>固定，根据可视区域大小实时进行尺寸调整，通常使用<code>max-width/min-width</code>控制尺寸范围过大或者过小。</li>
<li><strong>弹性布局</strong>。这种布局方案下，包裹文字的元素的尺寸采用<code>em/rem</code>为单位，页面主要划分区域的尺寸依据情况使用<code>px</code>、百分数或者<code>em/rem</code>。</li>
<li><strong>对于移动端web页面的自适应方案来说，现在用的比较多的是rem，逐渐向vw/vh发展，而rem+vw/vh则是作为vw/vh向后兼容的一种过渡。</strong></li>
</ul>
<h4 id="解决媒体查询的问题"><a href="#解决媒体查询的问题" class="headerlink" title="解决媒体查询的问题"></a>解决媒体查询的问题</h4><p>用rem方案</p>
<p>%</p>
<h4 id="做一个三角形"><a href="#做一个三角形" class="headerlink" title="做一个三角形"></a>做一个三角形</h4><ul>
<li>上三角形</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div &#123;    </span><br><span class="line">    <span class="attr">width</span>: <span class="number">0</span>;    </span><br><span class="line">    height: <span class="number">0</span>;    </span><br><span class="line">    border-top: 50px solid red;    </span><br><span class="line">    border-right: 50px solid transparent;    </span><br><span class="line">    border-left: 50px solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>下三角形</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">0</span>;</span><br><span class="line">    height: <span class="number">0</span>;</span><br><span class="line">    border-bottom: 50px solid red;</span><br><span class="line">    border-right: 50px solid transparent;</span><br><span class="line">    border-left: 50px solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>左三角形</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">0</span>;</span><br><span class="line">    height: <span class="number">0</span>;</span><br><span class="line">    border-left: 50px solid red;</span><br><span class="line">    border-top: 50px solid transparent;</span><br><span class="line">    border-bottom: 50px solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>右三角形</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    <span class="attr">width</span>: <span class="number">0</span>;</span><br><span class="line">    height: <span class="number">0</span>;</span><br><span class="line">    border-right: 50px solid red;</span><br><span class="line">    border-top: 50px solid transparent;</span><br><span class="line">    border-bottom: 50px solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h4 id="html5的新增特性"><a href="#html5的新增特性" class="headerlink" title="html5的新增特性"></a>html5的新增特性</h4><p>语义化标签</p>
<p>表单类型</p>
<p>表单属性</p>
<p>媒体标签</p>
<p>进度条、度量器</p>
<p>DOM查询操作</p>
<p>web存储</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2021/12/15/Vue/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2021/12/15/javascript/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            JavaScript
          
        </div>
      </a>
    
    
      <a href="/2021/12/11/vue-cli3%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E7%8E%AF%E5%A2%83%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">vue中配置生成环境和开发环境</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "",
    app_key: "",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src=''></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/uti/RecordingScreen.html">屏幕录制工具</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/wo/index.html">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>